import { module, test } from 'qunit';
import { setupTest } from 'frontend/tests/helpers';

/**
 * 
 * @param {*} context The assert context. Simply pass 'this' from assert.test = function() { rngTest(this) }
 * @param {*} rngFunc A function returning a number. Use as () => { return rng(...); }
 * @param {*} testFunc A function that tests whether the value generated by rngFunc is correct. Use as (value) => {return value == correct;}
 * @param {*} testIterationcount How many numbers should be generated/how many times the rng function should be tested.
 * @param {*} expected assert.pushresult({expected: value}). Currently only used to append to message.
 * @param {*} message The message to be displayed in the test UI. 
 *                    Should contain '{0}', which will be replaced by the correct results or the specific result that failed the test.
 */
function testRng(context, rngFunc, testFunc, testIterationcount, expected, message) {
  // Min max inclusive!
  let result = true;
  let results = [];
  for (let i = 0; i < testIterationcount; i++) {
    let generatedValue = rngFunc();
    results.push(generatedValue);
    if (!testFunc(generatedValue)) {
      result = false;
      results = [generatedValue];
      break;
    }
  }

  expected = expected.replace("{0}", results.join(' | '));

  context.pushResult({
    result: result,
    actual: result,
    expected: true,
    message: `${message} ${expected}`
  });
}

module('Unit | Route | twos/index', function (hooks) {
  setupTest(hooks);

  test('rng', function(assert) {
    let twos = this.owner.lookup('route:twos.index');
    assert.generatedValuesBetween = function(min, max, decimals=this.false, testIterationcount, message) {
      let func;
      if (!decimals) {
        func = () => {return twos.rng(min, max) };
      }
      else {
        func = () => {return twos.rng(min, max, decimals) };
      }
      testRng(this, func, (value) => {return min <= value && value <= max;}, testIterationcount, `${min} < {0} < ${max}`, message);
    }
    
    assert.correctAmountOfNumbersBeforeDecimal = function(min, max, numbersBeforeDecimal, testIterationcount, message) {
      let bottomMargin, topMargin;
      if (numbersBeforeDecimal != 0) {
        bottomMargin = Math.pow(10, numbersBeforeDecimal-1);
        topMargin = Math.pow(10, numbersBeforeDecimal);
      } else {
        bottomMargin = 0,
        topMargin = 1
      }

      let testFunc = function(value) {
        return bottomMargin <= value && value < topMargin;
      };

      testRng(this, () => {return twos.rng(min, max, numbersBeforeDecimal);}, testFunc, testIterationcount, `The following values all have ${numbersBeforeDecimal} numbers before the decimal. ${bottomMargin} <= {0} < ${topMargin}`, message)
    }
    

    assert.generatedValuesBetween(0, 50, false, 100, 'rng generates whole numbers between two numbers.');
    assert.generatedValuesBetween(0, 50, 2, 100, 'rng generates decimal numbers between two numbers.');

    assert.correctAmountOfNumbersBeforeDecimal(100, 500, 3, 100, 'rng can generate exactly 3 numbers before the decimal.');
    assert.correctAmountOfNumbersBeforeDecimal(10, 50, 2, 100, 'rng can generate exactly 2 numbers before the decimal.');
    assert.correctAmountOfNumbersBeforeDecimal(1, 5, 1, 100, 'rng can generate exactly 1 number before the decimal.');
    assert.correctAmountOfNumbersBeforeDecimal(0, 0, 0, 100, 'rng can generate exactly 0 numbers before the decimal.');

  });

});
